{"ast":null,"code":"import { __awaiter } from 'tslib';\nconst containerMap = {};\nconst remoteMap = {};\nlet isDefaultScopeInitialized = false;\n\nfunction lookupExposedModule(key, exposedModule) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const container = containerMap[key];\n    const factory = yield container.get(exposedModule);\n    const Module = factory();\n    return Module;\n  });\n}\n\nfunction initRemote(container, key) {\n  return __awaiter(this, void 0, void 0, function* () {\n    // const container = window[key] as Container;\n    // Do we still need to initialize the remote?\n    if (remoteMap[key]) {\n      return container;\n    } // Do we still need to initialize the share scope?\n\n\n    if (!isDefaultScopeInitialized) {\n      yield __webpack_init_sharing__('default');\n      isDefaultScopeInitialized = true;\n    }\n\n    yield container.init(__webpack_share_scopes__.default);\n    remoteMap[key] = true;\n    return container;\n  });\n}\n\nfunction loadRemoteEntry(remoteEntryOrOptions, remoteName) {\n  return __awaiter(this, void 0, void 0, function* () {\n    if (typeof remoteEntryOrOptions === 'string') {\n      const remoteEntry = remoteEntryOrOptions;\n      return yield loadRemoteScriptEntry(remoteEntry, remoteName);\n    } else if (remoteEntryOrOptions.type === 'script') {\n      const options = remoteEntryOrOptions;\n      return yield loadRemoteScriptEntry(options.remoteEntry, options.remoteName);\n    } else if (remoteEntryOrOptions.type === 'module') {\n      const options = remoteEntryOrOptions;\n      yield loadRemoteModuleEntry(options.remoteEntry);\n    }\n  });\n}\n\nfunction loadRemoteModuleEntry(remoteEntry) {\n  return __awaiter(this, void 0, void 0, function* () {\n    if (containerMap[remoteEntry]) {\n      return Promise.resolve();\n    }\n\n    return yield import(\n    /* webpackIgnore:true */\n    remoteEntry).then(container => {\n      initRemote(container, remoteEntry);\n      containerMap[remoteEntry] = container;\n    });\n  });\n}\n\nfunction loadRemoteScriptEntry(remoteEntry, remoteName) {\n  return __awaiter(this, void 0, void 0, function* () {\n    return new Promise((resolve, reject) => {\n      // Is remoteEntry already loaded?\n      if (containerMap[remoteName]) {\n        resolve();\n        return;\n      }\n\n      const script = document.createElement('script');\n      script.src = remoteEntry;\n      script.onerror = reject;\n\n      script.onload = () => {\n        const container = window[remoteName];\n        initRemote(container, remoteName);\n        containerMap[remoteName] = container;\n        resolve();\n      };\n\n      document.body.appendChild(script);\n    });\n  });\n} // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n\nfunction loadRemoteModule(options) {\n  return __awaiter(this, void 0, void 0, function* () {\n    let loadRemoteEntryOptions;\n    let key; // To support legacy API (< ng 13)\n\n    if (!options.type) {\n      options.type = 'script';\n    }\n\n    if (options.type === 'script') {\n      loadRemoteEntryOptions = {\n        type: 'script',\n        remoteEntry: options.remoteEntry,\n        remoteName: options.remoteName\n      };\n      key = options.remoteName;\n    } else if (options.type === 'module') {\n      loadRemoteEntryOptions = {\n        type: 'module',\n        remoteEntry: options.remoteEntry\n      };\n      key = options.remoteEntry;\n    }\n\n    if (options.remoteEntry) {\n      yield loadRemoteEntry(loadRemoteEntryOptions);\n    }\n\n    return yield lookupExposedModule(key, options.exposedModule);\n  });\n}\n/**\r\n * Generated bundle index. Do not edit.\r\n */\n\n\nexport { loadRemoteEntry, loadRemoteModule }; //# sourceMappingURL=angular-architects-module-federation-runtime.js.map","map":null,"metadata":{},"sourceType":"module"}